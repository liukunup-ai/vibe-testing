# AGENTS.md - AI 代理协作规范文档

## 一、文档概述

### 1.1 目的

本文档定义了自动化测试平台项目中 **AI 代理（Agent）** 的角色分类、能力边界、协作规范和工作流程。目的是建立一套标准化的多代理协作机制，确保在代码开发、测试执行、问题诊断等场景中，各代理能够高效协同工作，同时保持代码质量和系统稳定性。

### 1.2 适用范围

本文档适用于以下场景的 AI 代理协作：

| 场景 | 代理类型 | 协作模式 |
|-----|---------|---------|
| 代码开发 | Coding Agent | 单代理 / 多代理并行 |
| 自动化测试 | Testing Agent | 任务委派 |
| 问题诊断 | Analysis Agent | 专家会诊 |
| 架构设计 | Architecture Agent | 方案评审 |
| 运维部署 | DevOps Agent | 流水线协作 |

### 1.3 核心原则

- **专业分工**：每个代理专注于特定领域，避免跨领域越权
- **透明协作**：代理间的通信和决策过程应可追溯
- **质量优先**：所有产出必须经过验证，确保代码质量
- **持续改进**：根据执行结果反馈优化代理行为

---

## 二、代理分类与职责

### 2.1 代理层级体系

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                              代理层级金字塔                                       │
└─────────────────────────────────────────────────────────────────────────────────┘

                              ┌─────────────┐
                              │   协调层     │
                              │  Orchestrator │
                              └──────┬──────┘
                                     │
                     ┌───────────────┼───────────────┐
                     │               │               │
              ┌──────┴──────┐ ┌──────┴──────┐ ┌──────┴──────┐
              │   规划层     │ │   规划层     │ │   规划层     │
              │  Architect  │ │   Planner    │ │   Analyst    │
              └──────┬──────┘ └──────┬──────┘ └──────┬──────┘
                     │               │               │
          ┌──────────┼──────────┐    │    ┌──────────┼──────────┐
          │          │          │    │    │          │          │
    ┌─────┴─────┐ ┌──┴───┐ ┌──┴───┐ ┌──┴───┐ ┌──┴───┐ ┌──┴───┐
    │  执行层    │ │执行层 │ │执行层 │ │执行层 │ │执行层 │ │执行层 │
    │  Coder   │ │Tester│ │Docs  │ │Review │ │DevOps │ │Query │
    └───────────┘ └──────┘ └──────┘ └──────┘ └──────┘ └──────┘
```

### 2.2 协调层代理

#### 2.2.1 Orchestrator - 任务协调者

**职责定位**：系统级的任务调度与资源协调中心，负责接收用户请求、解析任务需求、协调各执行代理完成工作。

**核心能力**：

| 能力项 | 能力描述 |
|-------|---------|
| 需求解析 | 将自然语言需求转化为可执行任务 |
| 任务分解 | 将复杂任务拆分为原子子任务 |
| 资源分配 | 根据任务类型分配最合适的执行代理 |
| 进度追踪 | 监控任务执行进度，处理异常情况 |
| 结果整合 | 汇总各代理执行结果，生成最终输出 |

**触发条件**：

```
当用户请求包含以下特征时，由 Orchestrator 接管：

1. 复合请求（涉及多个功能模块）
   - "帮我创建一个用户认证功能，包括注册、登录、找回密码"
   
2. 跨领域请求（需要多种专业能力）
   - "分析系统的性能瓶颈，并给出优化方案"
   
3. 不确定请求（需要澄清和规划）
   - "我想做一个自动化测试平台"
   
4. 紧急任务（需要多代理并行）
   - "系统出现严重故障，立即排查并修复"
```

**工作流程**：

```
用户请求
     │
     ▼
┌────────────────┐
│  需求解析       │ ← 分析请求意图
└───────┬────────┘
        │
        ▼
┌────────────────┐
│  任务分解       │ ← 拆分子任务
└───────┬────────┘
        │
        ▼
┌────────────────┐
│  代理选择       │ ← 根据任务类型选择代理
└───────┬────────┘
        │
        ▼
    并行/串行执行
        │
        ▼
┌────────────────┐
│  结果整合       │ ← 汇总结果
└───────┬────────┘
        │
        ▼
   返回最终结果
```

### 2.3 规划层代理

#### 2.3.1 Architect - 架构设计师

**职责定位**：负责系统的架构设计、技术选型、方案评审，确保技术方案的合理性、可扩展性和可维护性。

**核心能力**：

| 能力项 | 能力描述 |
|-------|---------|
| 架构设计 | 设计系统的整体架构和模块划分 |
| 技术选型 | 评估和选择合适的技术栈和工具 |
| 方案评审 | 评审技术方案的可行性和风险 |
| 演进规划 | 规划系统的演进路径和技术债务治理 |
| 性能设计 | 设计高性能、高可用的系统架构 |

**专业领域**：

```
专长领域：
├── 微服务架构设计
├── 数据库架构设计
├── 分布式系统设计
├── 高并发系统设计
├── 安全性架构设计
└── 监控告警架构设计
```

**工作成果**：

| 成果类型 | 输出物 |
|---------|-------|
| 架构文档 | 系统架构设计文档 |
| 技术规范 | 技术选型报告 |
| 评审意见 | 架构评审报告 |
| 演进路线 | 技术演进路线图 |

#### 2.3.2 Planner - 任务规划师

**职责定位**：负责将需求转化为详细的开发计划，包括任务分解、工时估算、依赖关系分析和里程碑设定。

**核心能力**：

| 能力项 | 能力描述 |
|-------|---------|
| 需求分析 | 理解需求并转化为可执行的任务列表 |
| 任务分解 | 将需求拆分为原子级的开发任务 |
| 工时估算 | 评估每个任务的开发时间和难度 |
| 依赖分析 | 分析任务间的依赖关系和执行顺序 |
| 里程碑规划 | 设定关键里程碑和交付节点 |

**输出规范**：

```markdown
# 任务计划：[功能名称]

## 任务概述
- 需求描述：...
- 预期交付：...
- 计划周期：...

## 任务分解

| 序号 | 任务名称 | 优先级 | 预估工时 | 负责人 | 依赖 | 验收标准 |
|-----|---------|-------|---------|-------|------|---------|
| 1 | 数据库设计 | P0 | 4h | - | - | 设计评审通过 |
| 2 | API 开发 | P0 | 8h | 1 | API 测试通过 |
| 3 | 前端开发 | P1 | 16h | 2 | UI 验收通过 |
| ... | ... | ... | ... | ... | ... | ... |

## 里程碑

| 里程碑 | 时间点 | 交付物 |
|-------|-------|-------|
| M1 数据库设计完成 | D+1 | 数据库设计文档 |
| M2 API 开发完成 | D+3 | API 文档 + 测试报告 |
| M3 功能开发完成 | D+7 | 功能演示 |
```

#### 2.3.3 Analyst - 问题分析师

**职责定位**：负责分析系统问题、性能瓶颈、安全漏洞等复杂问题，提供根因分析和解决方案。

**核心能力**：

| 能力项 | 能力描述 |
|-------|---------|
| 根因分析 | 定位问题的根本原因，而非表象 |
| 性能分析 | 分析系统性能瓶颈和优化点 |
| 安全分析 | 发现并修复安全漏洞 |
| 趋势分析 | 基于历史数据预测问题趋势 |
| 优化建议 | 提供可行的优化方案 |

**分析流程**：

```
问题报告
    │
    ▼
┌────────────────┐
│  信息收集       │ ← 收集日志、监控数据、复现步骤
└───────┬────────┘
        │
        ▼
┌────────────────┐
│  问题分类       │ ← 分类：性能/功能/安全/配置
└───────┬────────┘
        │
        ▼
┌────────────────┐
│  深度分析       │ ← 使用工具进行深度分析
└───────┬────────┘
        │
        ▼
┌────────────────┐
│  根因定位       │ ← 确定问题的根本原因
└───────┬────────┘
        │
        ▼
┌────────────────┐
│  方案制定       │ ← 提出解决方案
└───────┬────────┘
        │
        ▼
   输出分析报告
```

### 2.4 执行层代理

#### 2.4.1 Coder - 代码工程师

**职责定位**：负责代码编写、重构、调试等开发工作，是最主要的执行代理。

**核心能力**：

| 能力项 | 能力描述 |
|-------|---------|
| 代码编写 | 根据需求实现功能代码 |
| 代码重构 | 优化代码结构和可读性 |
| Bug 修复 | 定位并修复程序错误 |
| 单元测试 | 编写和执行单元测试 |
| 代码注释 | 添加必要的代码注释 |
| API 文档 | 编写 API 接口文档 |

**能力分级**：

| 级别 | 能力范围 | 复杂度 |
|-----|---------|-------|
| Junior | 简单功能开发、代码修改 | 低 |
| Middle | 功能开发、代码重构 | 中 |
| Senior | 架构设计、复杂问题解决 | 高 |
| Expert | 系统级设计、性能优化 | 极高 |

**工作规范**：

```markdown
## 代码编写规范

### 命名规范
- 变量名：使用小驼峰，如 `userName`
- 常量名：使用全大写，如 `MAX_COUNT`
- 类名：使用大驼峰，如 `UserService`
- 文件名：使用小写下划线，如 `user_service.go`

### 代码结构
├── 函数长度：不超过 50 行
├── 嵌套深度：不超过 3 层
├── 参数个数：不超过 5 个
└── 圈复杂度：不超过 10

### 注释要求
├── 公共方法必须注释
├── 复杂逻辑需要注释
├── 特殊处理需要说明原因
└── 废弃代码及时删除
```

#### 2.4.2 Tester - 测试工程师

**职责定位**：负责测试用例设计、自动化测试脚本编写、测试执行和结果分析。

**核心能力**：

| 能力项 | 能力描述 |
|-------|---------|
| 用例设计 | 设计功能测试用例 |
| 脚本编写 | 编写自动化测试脚本 |
| 测试执行 | 执行各类测试任务 |
| 缺陷验证 | 验证 Bug 是否修复 |
| 性能测试 | 执行性能测试和压力测试 |
| 测试报告 | 生成测试报告 |

**测试类型覆盖**：

| 测试类型 | 覆盖范围 | 自动化程度 |
|---------|---------|-----------|
| 单元测试 | 函数/方法级别 | ✅ 全自动化 |
| 接口测试 | API 级别 | ✅ 全自动化 |
| UI 测试 | 前端页面 | ✅ 部分自动化 |
| 集成测试 | 模块间集成 | ⚠️ 半自动化 |
| 性能测试 | 系统性能 | ⚠️ 半自动化 |
| 安全测试 | 安全漏洞 | ❌ 人工为主 |

#### 2.4.3 Docs - 文档工程师

**职责定位**：负责项目文档、技术文档、用户手册等各类文档的编写和维护。

**核心能力**：

| 能力项 | 能力描述 |
|-------|---------|
| 架构文档 | 编写系统架构设计文档 |
| API 文档 | 编写和维护 API 接口文档 |
| 用户手册 | 编写用户使用手册 |
| 开发指南 | 编写开发者指南 |
| 运维文档 | 编写运维操作手册 |
| 文档维护 | 保持文档与代码同步 |

#### 2.4.4 Review - 代码评审员

**职责定位**：负责代码评审，确保代码质量、风格统一、安全合规。

**评审维度**：

| 维度 | 检查项 |
|-----|-------|
| 正确性 | 代码逻辑是否正确 |
| 完整性 | 功能是否完整 |
| 可读性 | 代码是否易读 |
| 可维护性 | 代码是否易维护 |
| 性能 | 是否有性能问题 |
| 安全 | 是否有安全漏洞 |
| 风格 | 是否符合编码规范 |

#### 2.4.5 DevOps - 运维工程师

**职责定位**：负责 CI/CD 流水线、部署配置、环境管理、监控告警等运维工作。

**核心能力**：

| 能力项 | 能力描述 |
|-------|---------|
| CI/CD | 维护 CI/CD 流水线 |
| 部署 | 执行应用部署 |
| 配置 | 管理配置文件 |
| 监控 | 部署监控告警 |
| 日志 | 管理日志系统 |
| 扩缩容 | 管理服务扩缩容 |

#### 2.4.6 Query - 查询分析员

**职责定位**：负责数据查询、日志分析、信息检索等查询类任务。

**核心能力**：

| 能力项 | 能力描述 |
|-------|---------|
| 日志查询 | 查询和分析系统日志 |
| 数据查询 | 查询和分析数据库数据 |
| 问题检索 | 检索已知问题的解决方案 |
| 知识查询 | 查询项目知识库 |
| 文档检索 | 检索技术文档 |

---

## 三、代理协作规范

### 3.1 任务委派规则

#### 3.1.1 任务类型识别

```
任务类型识别规则：

1. 识别关键词
   ├── "创建/开发/实现" → Coder
   ├── "测试/验证" → Tester
   ├── "分析/诊断/排查" → Analyst
   ├── "设计/架构/方案" → Architect
   ├── "文档/编写" → Docs
   ├── "评审/检查" → Review
   ├── "部署/运维" → DevOps
   └── "查询/搜索" → Query

2. 识别复杂度
   ├── 简单任务 → 对应执行层代理直接处理
   ├── 中等任务 → 规划层代理制定计划后执行
   └── 复杂任务 → 协调层代理协调多代理处理

3. 识别依赖
   ├── 无依赖 → 独立执行
   ├── 有依赖 → 按依赖关系调度
   └── 跨领域 → 多代理协作
```

#### 3.1.2 任务委派流程

```
用户请求
     │
     ▼
┌─────────────────┐
│  任务类型识别     │ ← NLP 解析请求意图
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  复杂度评估       │ ← 评估任务复杂度
└────────┬────────┘
         │
    ┌────┴────┐
    │         │
    ▼         ▼
简单任务    复杂任务
    │         │
    ▼         ▼
┌────────┐ ┌─────────────────┐
│直接委派 │ │ 规划层介入       │
└────────┘ └────────┬────────┘
                    │
                    ▼
            ┌─────────────────┐
            │  多代理协调       │
            └────────┬────────┘
                    │
                    ▼
            ┌─────────────────┐
            │  执行与监控       │
            └────────┬────────┘
                    │
                    ▼
            ┌─────────────────┐
            │  结果整合        │
            └─────────────────┘
```

### 3.2 通信协议

#### 3.2.1 代理通信格式

```json
{
  "message_id": "msg_xxx",
  "sender": "agent_type",
  "receiver": "agent_type",
  "message_type": "request/response/notify",
  "timestamp": "2024-01-20T10:30:00Z",
  "content": {
    "task_id": "task_xxx",
    "action": "action_name",
    "parameters": {},
    "context": {}
  },
  "priority": "high/normal/low",
  "metadata": {
    "trace_id": "trace_xxx",
    "span_id": "span_xxx"
  }
}
```

#### 3.2.2 响应格式

```json
{
  "message_id": "msg_xxx",
  "sender": "agent_type",
  "status": "success/failed/partial",
  "result": {},
  "error": {
    "code": "error_code",
    "message": "错误描述",
    "details": {}
  },
  "metrics": {
    "execution_time_ms": 1000,
    "tokens_used": 5000
  },
  "next_actions": []
}
```

### 3.3 上下文传递

#### 3.3.1 会话上下文

```
会话上下文结构：

{
  "session_id": "session_xxx",
  "user_id": "user_xxx",
  "project_context": {
    "project_name": "xxx",
    "tech_stack": ["Go", "React", "PostgreSQL"],
    "coding_standards": {}
  },
  "conversation_history": [
    {
      "role": "user/agent",
      "content": "...",
      "timestamp": "..."
    }
  ],
  "working_memory": {
    "current_task": {},
    "pending_tasks": [],
    "completed_tasks": []
  }
}
```

#### 3.3.2 任务上下文

```
任务上下文结构：

{
  "task_id": "task_xxx",
  "task_type": "coding/testing/docs",
  "priority": "high",
  "requirements": {
    "functional": [],
    "non_functional": []
  },
  "constraints": {
    "deadline": "2024-01-30",
    "budget": 100,
    "technology_limitations": []
  },
  "resources": {
    "files": [],
    "dependencies": [],
    "environments": []
  },
  "acceptance_criteria": []
}
```

### 3.4 冲突处理

#### 3.4.1 代理冲突类型

| 冲突类型 | 场景 | 处理策略 |
|---------|------|---------|
| 能力冲突 | 多个代理都能处理 | 按专业度优先级 |
| 资源冲突 | 多个任务争抢资源 | 按优先级调度 |
| 意见冲突 | 多个代理意见不一致 | 升级到协调层 |
| 依赖冲突 | 任务依赖形成循环 | 重新规划依赖 |

#### 3.4.2 冲突解决流程

```
冲突检测
    │
    ▼
┌────────────────┐
│  冲突类型分类    │
└───────┬────────┘
        │
        ▼
┌────────────────┐
│  解决策略选择    │
│  • 重试         │ ← 可重试冲突
│  • 等待         │ ← 临时性冲突
│  • 升级         │ ← 无法解决冲突
│  • 跳过         │ ← 可忽略冲突
└───────┬────────┘
        │
        ▼
┌────────────────┐
│  解决结果记录    │
└────────────────┘
```

---

## 四、工作流程规范

### 4.1 需求实现流程

```
需求输入
    │
    ▼
┌─────────────────────────────────────────────────────────────────┐
│  需求分析阶段                                                   │
│  ├─ Planner: 需求理解与澄清                                      │
│  ├─ Planner: 任务分解与计划制定                                  │
│  └─ Architect: 技术方案评审（如需要）                            │
└─────────────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────────────┐
│  开发执行阶段                                                   │
│  ├─ Coder: 代码编写                                              │
│  ├─ Tester: 单元测试编写                                         │
│  └─ Review: 代码评审                                             │
└─────────────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────────────┐
│  集成测试阶段                                                   │
│  ├─ Tester: 接口测试                                             │
│  ├─ Tester: 集成测试                                            │
│  └─ DevOps: CI/CD 执行                                           │
└─────────────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────────────┐
│  交付验收阶段                                                   │
│  ├─ Analyst: 性能测试（如需要）                                   │
│  ├─ Docs: 文档更新                                               │
│  └─ Review: 最终验收                                             │
└─────────────────────────────────────────────────────────────────┘
```

### 4.2 问题处理流程

```
问题报告
    │
    ▼
┌─────────────────────────────────────────────────────────────────┐
│  问题分类                                                       │
│  ├─ Bug（程序错误）                                              │
│  ├─ Defect（功能缺陷）                                           │
│  ├─ Issue（使用问题）                                           │
│  └─ Vulnerability（安全问题）                                    │
└─────────────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────────────┐
│  根因分析                                                       │
│  ├─ Analyst: 信息收集                                            │
│  ├─ Analyst: 问题复现                                           │
│  └─ Analyst: 根因定位                                           │
└─────────────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────────────┐
│  方案制定                                                       │
│  ├─ Analyst: 解决方案制定                                        │
│  └─ Architect: 方案评审（如涉及架构）                            │
└─────────────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────────────┐
│  修复执行                                                       │
│  ├─ Coder: 代码修复                                              │
│  ├─ Tester: 验证测试                                             │
│  └─ DevOps: 发布更新                                             │
└─────────────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────────────┐
│  复盘总结                                                       │
│  ├─ Analyst: 问题总结                                            │
│  └─ Docs: 文档更新                                               │
└─────────────────────────────────────────────────────────────────┘
```

### 4.3 架构设计流程

```
设计需求
    │
    ▼
┌─────────────────────────────────────────────────────────────────┐
│  现状调研                                                       │
│  ├─ Query: 现有架构调研                                         │
│  ├─ Query: 技术债务梳理                                          │
│  └─ Query: 性能基线获取                                          │
└─────────────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────────────┐
│  方案设计                                                       │
│  ├─ Architect: 架构设计                                         │
│  ├─ Architect: 技术选型                                          │
│  └─ Architect: 详细设计                                          │
└─────────────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────────────┐
│  方案评审                                                       │
│  ├─ Planner: 成本估算                                            │
│  └─ Review: 可行性评审                                           │
└─────────────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────────────┐
│  实施与验证                                                     │
│  ├─ Coder: 架构实施                                              │
│  ├─ Tester: 性能验证                                             │
│  └─ Analyst: 效果评估                                            │
└─────────────────────────────────────────────────────────────────┘
```

---

## 五、质量保证规范

### 5.1 代码质量标准

#### 5.1.1 代码评审标准

```
代码评审检查清单：

□ 功能正确性
  ├── 逻辑是否正确
  ├── 边界条件是否处理
  ├── 异常情况是否处理
  └── 单元测试是否通过

□ 代码质量
  ├── 命名是否清晰
  ├── 注释是否充分
  ├── 函数长度是否合适
  ├── 嵌套深度是否合理
  └── 重复代码是否提取

□ 性能安全
  ├── 是否有性能瓶颈
  ├── 是否有内存泄漏
  ├── 是否有安全漏洞
  └── 是否有并发问题

□ 规范一致
  ├── 是否符合编码规范
  ├── 是否符合项目约定
  ├── API 设计是否合理
  └── 数据库设计是否规范
```

#### 5.1.2 测试覆盖率标准

| 测试类型 | 最低覆盖率 | 目标覆盖率 |
|---------|-----------|-----------|
| 单元测试 | 70% | 80% |
| 接口测试 | 80% | 90% |
| 关键路径测试 | 100% | 100% |
| 安全测试 | 60% | 80% |

### 5.2 文档质量标准

| 文档类型 | 必备要素 | 更新频率 |
|---------|---------|---------|
| API 文档 | 请求示例、响应示例、错误码说明 | 与代码同步 |
| 架构文档 | 架构图、技术选型、演进计划 | 季度更新 |
| 用户手册 | 操作步骤、截图示例、常见问题 | 按需更新 |
| 开发者指南 | 环境搭建、开发规范、调试指南 | 季度更新 |
| 运维手册 | 部署步骤、配置说明、故障处理 | 按需更新 |

### 5.3 性能质量标准

| 指标类型 | 指标项 | 阈值 |
|---------|-------|-----|
| 响应时间 | API 平均响应时间 | < 200ms |
| 响应时间 | 页面加载时间 | < 3s |
| 吞吐量 | QPS | > 1000 |
| 可用性 | 系统可用率 | > 99.9% |
| 错误率 | API 错误率 | < 0.1% |

---

## 六、代理能力评估

### 6.1 能力评分模型

```
能力评分维度：

┌───────────────────────────────────────────────────────────────┐
│  能力评分 = w1×任务完成度 + w2×代码质量 + w3×执行效率         │
│                     + w4×文档质量 + w5×协作评价                │
│  其中：w1+w2+w3+w4+w5 = 1.0                                  │
└───────────────────────────────────────────────────────────────┘

维度定义：
├── 任务完成度：任务是否按要求完成
├── 代码质量：代码的规范性、健壮性
├── 执行效率：完成任务的时间和资源消耗
├── 文档质量：配套文档的完整性和准确性
└── 协作评价：与其他代理协作的效果
```

### 6.2 持续优化机制

```
┌─────────────────────────────────────────────────────────────┐
│                      持续优化闭环                            │
└─────────────────────────────────────────────────────────────┘

执行 → 评估 → 分析 → 优化 → 执行
  │                        │
  │    ┌───────────────────┘
  │    │
  ▼    ▼
┌─────────────────┐
│  收集执行数据    │ ← 记录每个任务的执行情况
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  评估执行效果    │ ← 根据评分模型评估
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  分析改进空间    │ ← 识别问题和改进点
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  优化代理行为    │ ← 调整策略和参数
└─────────────────┘
```

---

## 七、异常处理规范

### 7.1 异常分类

| 异常类型 | 描述 | 处理策略 |
|---------|------|---------|
| ValidationError | 输入验证错误 | 返回错误提示 |
| AuthenticationError | 认证错误 | 重新认证 |
| AuthorizationError | 权限错误 | 拒绝访问 |
| ResourceNotFound | 资源不存在 | 返回 404 |
| BusinessError | 业务错误 | 业务错误处理 |
| SystemError | 系统错误 | 降级处理 |
| TimeoutError | 超时错误 | 重试或降级 |

### 7.2 降级策略

```
降级策略矩阵：

┌─────────────────┬─────────────────────────────────────────┐
│  异常类型        │  降级策略                                 │
├─────────────────┼─────────────────────────────────────────┤
│  依赖服务不可用   │  返回缓存数据或默认值                      │
├─────────────────┼─────────────────────────────────────────┤
│  执行超时         │  中止任务，返回部分结果                     │
├─────────────────┼─────────────────────────────────────────┤
│  资源不足         │  减少并发，排队处理                        │
├─────────────────┼─────────────────────────────────────────┤
│  权限不足         │  回退到基础功能                           │
├─────────────────┼─────────────────────────────────────────┤
│  未知错误         │  记录日志，返回友好错误                    │
└─────────────────┴─────────────────────────────────────────┘
```

---

## 八、附录

### 8.1 代理能力矩阵

| 代理 | 核心能力 | 辅助能力 | 协作对象 |
|-----|---------|---------|---------|
| Orchestrator | 任务调度、资源协调 | 需求解析 | 全部 |
| Architect | 架构设计、技术选型 | 方案评审 | Planner, Review |
| Planner | 任务规划、进度追踪 | 成本估算 | Architect, Coder |
| Analyst | 问题分析、根因定位 | 性能优化 | Coder, Tester |
| Coder | 代码编写、调试 | 重构, 单元测试 | Tester, Review |
| Tester | 用例设计、测试执行 | 缺陷验证 | Coder, DevOps |
| Docs | 文档编写 | 知识管理 | 全部 |
| Review | 代码评审 | 安全检查 | Coder, Architect |
| DevOps | CI/CD、部署运维 | 监控告警 | Tester, Coder |
| Query | 信息检索 | 数据分析 | 全部 |

### 8.2 消息类型定义

| 消息类型 | 说明 | 使用场景 |
|---------|------|---------|
| request | 请求消息 | 发起任务请求 |
| response | 响应消息 | 任务执行结果 |
| notify | 通知消息 | 状态变更通知 |
| query | 查询消息 | 信息查询请求 |
| command | 命令消息 | 强制执行命令 |
| error | 错误消息 | 错误报告 |

### 8.3 状态码定义

| 状态码 | 说明 | 处理建议 |
|-------|------|---------|
| 200 | 成功 | 返回结果 |
| 400 | 请求错误 | 检查请求参数 |
| 401 | 未认证 | 重新认证 |
| 403 | 无权限 | 申请权限 |
| 404 | 资源不存在 | 检查资源ID |
| 429 | 请求过多 | 限流处理 |
| 500 | 服务器错误 | 重试或升级 |
| 503 | 服务不可用 | 降级处理 |

### 8.4 变更记录

| 版本 | 日期 | 变更内容 | 作者 |
|-----|------|---------|------|
| 1.0.0 | 2024-01-20 | 初始版本 | - |

---

## 九、前端 OpenAPI 自动化文档

### 9.1 概述

本项目使用 **Umi Max OpenAPI 插件** 自动从后端 Swagger 文档生成前端 API 服务代码，确保前后端接口保持一致。

### 9.2 工作原理

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                          OpenAPI 自动生成流程                                     │
└─────────────────────────────────────────────────────────────────────────────────┘

后端 Swagger 文档                                    前端生成文件
    │                                                    │
    ▼                                                    ▼
┌──────────────┐         ┌──────────────┐         ┌──────────────┐
│  /swagger/   │ ──────▶ │  npm run     │ ──────▶ │ src/services/│
│  doc.json    │  fetch  │  openapi     │  生成   │ auth/*.ts    │
└──────────────┘         └──────────────┘         └──────────────┘
                              │
                              ▼
                     ┌──────────────┐
                     │ config.ts    │
                     │ openAPI配置   │
                     └──────────────┘
```

### 9.3 配置方式

#### 9.3.1 后端 Swagger 端点

确保后端服务提供 Swagger JSON 文档：

```
http://127.0.0.1:7001/swagger/doc.json
```

#### 9.3.2 前端 OpenAPI 配置

**文件**: `frontend/config/config.ts`

```typescript
openAPI: [
  {
    requestLibPath: "import { request } from '@umijs/max'",
    // 从后端动态获取 Swagger 文档
    // 确保后端服务已启动（端口 7001）
    schemaPath: 'http://127.0.0.1:7001/swagger/doc.json',
    projectName: 'auth',
  },
],
```

#### 9.3.3 配置项说明

| 配置项 | 类型 | 说明 |
|-------|------|------|
| `requestLibPath` | string | 请求库的导入路径 |
| `schemaPath` | string | Swagger 文档路径（本地文件或 URL） |
| `projectName` | string | 项目名称，影响生成目录结构 |

### 9.4 使用流程

#### 步骤 1：启动后端服务

```bash
# 后端服务必须先启动，才能获取 Swagger 文档
cd backend
go run ./cmd/server
```

#### 步骤 2：生成前端 API

```bash
cd frontend
npm run openapi
```

**输出示例**：

```
> ant-design-pro@6.0.0 openapi
> max openapi

😄 Hello PRO
Using openAPI Plugin
[openAPI]: ✅ 成功生成 service 文件
[openAPI]: 💺 将 Swagger 转化为 openAPI
[openAPI]: ✅ 成功生成 service 文件
```

#### 步骤 3：使用生成的 API

生成的文件位于 `frontend/src/services/auth/` 目录：

```
src/services/auth/
├── index.ts              # 服务导出
├── authentication.ts     # 认证相关 API
└── typings.d.ts         # 类型定义
```

**使用示例**：

```typescript
import { postLogin, postRegister } from '@/services/auth';

// 登录
const handleLogin = async (values: API.LoginRequest) => {
  const response = await postLogin(values);
  if (response.code === 0) {
    // 登录成功
  }
};

// 注册
const handleRegister = async (values: API.RegisterRequest) => {
  await postRegister(values);
};
```

### 9.5 生成文件说明

#### 9.5.1 API 服务文件

每个 API 端点会生成对应的请求函数：

```typescript
// src/services/auth/authentication.ts

/** 用户登录 POST /api/v1/login */
export async function postLogin(
  body: API.LoginRequest,
  options?: { [key: string]: any }
) {
  return request<API.LoginResponse>("/api/v1/login", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    data: body,
    ...(options || {}),
  });
}
```

#### 9.5.2 类型定义文件

```typescript
// src/services/auth/typings.d.ts

declare namespace API {
  type LoginRequest = {
    email: string;
    password: string;
  };

  type LoginResponse = {
    code?: number;
    data?: LoginResponseData;
    message?: string;
  };

  type LoginResponseData = {
    accessToken?: string;
    expiresIn?: number;
    refreshToken?: string;
    tokenType?: string;
  };
}
```

### 9.6 注意事项

#### 9.6.1 后端端口

确保后端运行在 **7001** 端口，否则无法获取 Swagger 文档。

#### 9.6.2 路径前缀

如果后端 API 路径包含 `/api/v1/` 前缀，生成的代码会自动保留。代理配置（`proxy.ts`）负责处理路径转发。

#### 9.6.3 类型安全

生成的代码是类型安全的，如果后端返回结构变化，需要重新运行 `npm run openapi`。

### 9.7 代理配置

**文件**: `frontend/config/proxy.ts`

```typescript
export default {
  dev: {
    '/api/': {
      target: 'http://127.0.0.1:7001',
      changeOrigin: true,
      pathRewrite: { '^/api': '' },
    },
  },
};
```

### 9.8 最佳实践

1. **开发流程**：
   - 先启动后端服务
   - 再启动前端开发服务
   - 后端 API 变更后，运行 `npm run openapi` 更新前端代码

2. **版本控制**：
   - 建议将生成的 API 文件提交到 Git
   - 便于追踪 API 变更历史

3. **团队协作**：
   - 后端 API 变更后，通知前端团队重新生成
   - 使用 CI/CD 自动触发更新

4. **错误处理**：
   - 使用 `requestErrorConfig.ts` 统一处理错误
   - 确保错误码与后端一致

